# java基础

### 1.解释下java接口(interface)的作用
    定义了一个规范,接口可以多实现

### 2.Session和cookie的却别?
    cookie数据存储在客户的浏览器上,session存放在服务器上
    cookie的数据不是很安全,别人可以拿到你本地的cookie进行数据欺骗,模拟登录
    当然考虑安全可以使用session
    session会在一定的时间内保存在服务器上,当访问曾多,会比较占用服务器的性能,
    单个cookie的数据不超多4K,很多浏览器的站点允许最多不超过20个cookie

### 3.java线程和进程的区别?
	1.线程是cpu独立运行和独立调度的基本单元
	2.进程是资源分配的基础单位,是执行着的程序
	两个的联系:都是操作系统运行程序的基础单元
	两者的区别:
		1.进程具有独立的空间地址,一个进程崩溃后,在保护模式下,不会影响其他进程
		2.线程只是一个进程的不同执行路径,线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉。进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。

### java nio和bio的区别?
	1.bio是同步阻塞,数据的读写会阻塞在一个线程中,适用于链接数目比较小且固定的架构,对服务器的资源要求高,
	2.nio是同步非阻塞的,通过Selector监听Channel上事件的变化,在Channel上有数据发生变化时通知该线程进行读写操作适用于连接数目比较多且连接比较短的架构

### java的JDK 和 JRE 有什么区别？
    jdk是java开发的环境 
    jre是java运行的环境
    jdk包含了jre

### java的== 和 equals 的区别是什么？
    基本数据类型：== 比较的是值是否相等
    引用数据类型：== 比较的是地址值是否相等
    equals其实就是== 只是很多类重写了equals()方法

### 



# 一: 数据结构
### 1.hashmap 和 LinkedHashMap 和 TreeMap 和 HashTable 和 ConcurrentHashMap 介绍
#### 1.hashmap?
       hashmap 1.为线程不安全的,所以效率相对来说高一些
               2.底层为数据+链表(jdk1.7之前)
               3.允许key/value为null,key不可以重复,value不能重复
       hashmap的put方法
 ![Alt](https://upload-images.jianshu.io/upload_images/7853175-a8950349acda7799.png?,mageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp =30x30)分析整个put过程得出结果
    首先在1.7之前 hashmap的底层是数组加链表,我们都知道hashmap是线程不安全的,而且存储的数据都可以为null,而线程不安全的情况下我们对数组进行扩容的时候会出现一个死循环,当链表长度大于8数组大于等于64的时候是红黑树,红黑树节点个数小于6的时候转化为链表
    hashmap的插入?
    	首先初始化一个数组的长度,判断数组是否为空,如果不为空插入数据
    多线程的情况下会出现什么问题?多线程put后可能导致get死循环,多线程put的时候可能导致元素丢失,put非null元素后get出来的却是null


#### 2.HashTable?
       1.底层为数组+链表实现
       2.key和 value都不为空 
       3.线程安全的(实现线程安全的方法是在修改数据时,锁住整个hashtable(分段锁)),效率较低
       4.初始化size为11,扩容为 newsize = oldsize*2+1

#### 3.TreeMap?
      1.基于红黑书
      2.线程不安全
      3.key值不允许为null,key不可以重复,value可以重复

#### 4.LinkedHashMap?
       介绍之前我们都知道,hashmap为数组+单向链表,linkedList为双向链表实现,所以linkedHashMap为(linkedlist+hashmap)的集合,linkedHashmap继承自hashmap,它新增put和获取get的方法都是复用父类HashMap的代码,只是重写了put给get内部的某些接口,
       1.LinkedHashMap数据存储和hashmap相同,数组+单向链表,只是在每次的Entry中增加了用于维护顺序的before和after变量来维护一个双向链表来保存

#### 5.ConcurrentHashMap?
       1.底层是分段的数组+链表实现 线程安全
       2.通过把整个map分为N个Segment,可以提供相同的线程安全,但是效率提升N倍,默认提升16倍,(读操作不加锁,由于HashEntry的value变量是volatile的,也能包区读取到最新的值)
       3.Hashtable的synchronized是针对整张Hash表的,即每次锁住整张表让线程独占ConcurrentHashMap允许多个修改操作并发进行,其关键在于使用了锁分离技术

### 6.hashSet有什么功能,基于那个类实现?
      1.存的元素不能为空,元素不能重复
      2.基于hashMap实现

### 7.ConcurrentHashMap并发能力为什么比HashTable好?
      1.HashTable是通过对hash表整体进行锁定,是阻塞式的,当一个线程占有这个锁的时候,其他线程必须阻塞当前线程释放锁
      2.而ConcurrentHashMap的实现则是(1.6)采用Segment分段锁的方式,他并没有对这个数据结构进行锁定,而是局部锁
      3.jdk1.8之后采用了一种乐观锁的CAS 算法来实现同步问题,但是底层还是数据+链表+红黑树实现

### 4.hashmap和ConcurrentHashMap的区别?
    hashmap是线程不安全的,底层是数组+链表+红黑树(1.7后),存储的数据key和value可以为null,
    ConcurrentHashMap是线程安全的,并不是每个方法都加上了synchronized修饰方法,那不成了hashtable了,底层其实是映入了一个分段锁的概念,具体可以理解为把一个大的map拆分为多个小的hashtable,更具key.hashCode()来决定把key放到那个hashtable中,在ConcurrentHashMap中把map拆分了n个Segmentput和get的时候，都是现根据key.hashCode()算出放到哪个Segment中：

### 5.List的初始化大小和扩容机制
    list的初始化大小是0当list里面add数据之后,初始容量就会变成10,而扩容的机制是当发现当前扩容机制不够用的时候,就会扩容,也就是当抢扩容机制为大于等于10的时候回去扩容,arrayListd的扩容是原容量的1.5倍




# 二:java 多线程问题

### 1.线程的实现方法
     1.继承thread类,重写run 方法
         优点:编码简单(常用)
         缺点:不能继承其他类,
     2.实现Runnable接口,重写Run方法,
         优点:可以继承其他的类,避免单继承的局限,适用于多个相同程序的线程共享一个资源(同一个线程任务对象可被包装成多个线程对象),实现解耦操作，代码和线程独立
         缺点:实现相对复杂
     3.实现Callable接口重写run方法
         优点:相比Runnable接口可以获取返回值
         缺点是实现起来比较复杂

### 2.线程的状态?
    1.新建状态
        >使用 new 关键字和 Thread 类或其子类建立一个线程对象后,该线程对象就处于新建状态
    2.就绪状态
        >当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度
    3.运行状态
        >如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
    4.阻塞状态
        >如果一个线程执行了sleep（睡眠）,suspend（挂起）等方法,失去所占用资源之后,该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态
        等待阻塞:运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
        同步阻塞:线程在获取 synchronized同步锁失败(因为同步锁被其他线程占用)
        其他阻塞:通过调用线程的 sleep() 或 join() 发出了 I/O请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
    5.死亡/消亡状态
        一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

### 3.volatile关键字的作用?
    1.保证修饰的变量对所有线程可见,线程修改了变量值后,新的值对其他变量值可见
    2.禁止指令重排:被修饰的变量不会被缓存在寄存器中或者对其他处理器不可见的地方
    3.不会执行加锁操作:不会导致线程阻塞，主要适用于一个变量被多个线程共享,多个线程均可对这个变量执行赋值或读取的操作。
    4.volatile保证变量的单次读写操作的原子性,但并不能保证像i++这种操作的原子性，因为i++在本质上是读、写两次操作

### 4.synchronized关键字的作用?     
    1.synchronized用于java对象,方法,代码块提供线程安全操作,属于排他的悲观锁,也属于可充入锁,
    2.synchronized随时的方法和代码块在同一时刻只能被一个线程访问
    3.Java中的每个对象都有一个monitor监视器对象，加锁就是在竞争monitor，对代码块加锁是通过在前后分别加上monitorenter和monitorexit指令实现的，对方是否加锁是通过一个标记位来判断的。

### 5.synchronized关键字的实现原理? 
    1.收到新的锁请求时首先自旋,如果通过自旋没有获取资源,被放入ContentionList(该做法对于已经进入队列的线程是不公平的，体现了synchronized的不公平性)
    2.为了防止ContentionList尾部的元素被大量线程进行CAS访问影响性能Owner线程会在是释放锁时将ContentionList的部分线程移动到EntryList并指定某个线程（一般是最先进入的）为OnDeck线程。Owner并没有将锁直接传递给OnDeck线程而是把锁竞争的权利交给他，该行为叫做竞争切换，牺牲了公平性但提高了性能
    3.获取到锁的OnDeck线程会变为Owner线程，未获取到的仍停留在EntryList中。④Owner线程在被wait阻塞后会进入WaitSet，直到某个时刻被唤醒再次进入EntryList。

### 6.synchronized锁的升级过程? 
    首先是引入自旋锁--->锁消除--->锁粗化--->轻量级锁--->偏向锁
    锁可以从偏向锁---->轻量级锁---->重量级锁(过程叫)锁膨胀

### 7.什么是ThreadLocal?
    1.ThreadLocal用来解决多线程程序的并发问题(本地线程)
    2.ThreadLocal是一个局部变量,当使用ThreadLocal维护局部变量时候,ThreadLocal为每个使用该变量的线程提供独立的变量副本,所以每个线程都可以独立地改变自己的副本,而不会影响其他线程所对应的副本(原理就是底层维护了一个map)

### 8.java中有哪些锁? 主要是什么作用?
    1.java中的锁主要用于保障多并发下数据的一直性,线程必须先获取锁才能进行操作,可以保证数据的安全
    2.分类:
      2.2.乐观锁和悲观锁的角度分为:乐观所和悲观锁
      2.3.获取资源的公平性分为:公平锁和非公平锁
      2.4.从是否共享资源的角度分为:共享锁和排他锁
      2.5.锁的状态可以分为,偏向锁 轻量级锁,重量级锁

###  9.讲一讲乐观锁和悲观锁
     1.乐观锁采用乐观的思想处理数据，在每次读取数据时都认为别人不会修改该数据，所以不会上锁。但在更新时会判断在此期间别人有没有更新该数据，通常采用在写时先读出当前版本号然后加锁的方法，具体过程为：比较当前版本号与上一次的版本号，如果一致则更新，否则重复进行读、比较、写操作。Java中的乐观锁是基于CAS操作实现的，CAS是一种原子性操作，在对数据更新之前先比较当前值和传入的值是否一样，一样则更新否则直接返回失败状态。
    2.悲观锁采用悲观的思想处理数据，每次读取数据时都认为别人会修改数据，所以每次都会上锁，其他线程将被阻塞。Java中的悲观锁基于AQS实现，该框架下的锁会先尝试以CAS乐观锁去获取锁，如果获取不到则会转为悲观锁。

### 10.讲一讲自旋锁?
    1.自旋锁认为如果持有锁的线程能在很短的时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞、挂起状态，只需等待小段时间，在等待持有锁的线程释放锁后即可立即获取锁，这样就避免了用户线程在内核态的切换上导致锁时间消耗。
    2.优点：减少CPU的上下文切换，对于占用锁时间非常短或锁竞争不激烈的代码块来说性能很高。
    3.缺点：在持有锁的线程长时间占用锁或竞争过于激烈时，线程会长时间自旋浪费CPU资源，有复杂锁依赖的情况不适合使用自旋锁。

### 11.讲一讲公平锁与非公平锁?
    1.公平锁指在分配锁前检查是否有线程在排队等待获取该锁，优先将锁分配给排队时间最长的线程。
    2.非公平锁指在分配锁时不考虑线程排队等待的情况，直接尝试获取锁，获取不到锁就在排到队尾等待。
    3.因为公平锁需要在多核情况下维护一个锁线程等待队列，基于该队列进行锁的分配，因此效率比非公平锁低很多。synchronized是非公平锁，ReentrantLock默认的lock方法也是非公平锁。

### 12.讲一讲读写锁
    1.Lock接口提供的锁是普通锁，为了提高性能Java提供了读写锁，读写锁分为读锁和写锁，读锁之间不互斥，读锁与写锁，写锁之间都互斥。
    2.如果系统要求共享数据可以同时支持很多线程并发读，但不能支持很多线程并发写，那么读锁能大大提高效率。如果系统要求共享数据在同一时刻只能有一个线程在写，且写的过程中不能读，则需要使用写锁。
    3.提高juc的locks包中ReadWriteLock的实现类ReentrantReadWriteLock的readLock()和writeLock()来分别获取读锁和写锁。

### 13.讲一讲共享锁与排它锁
    1.共享锁：允许多个线程同时获取该锁，并发访问共享资源，ReentrantReadWriteLock的读锁为共享锁的实现。
    2.排它锁：也叫互斥锁 ，每次只允许有一个线程独占该锁，ReentrantLock为排它锁的实现。
    3.排它锁是一种悲观的加锁策略，同一时刻只允许一个线程读取锁资源，限制了读操作的并发性，因为并发读线程并不会影响数据的一致性，因此共享锁采用了乐观的加锁策略，允许多个执行读操作的线程同时访问共享资源。

### 14.锁有哪些状态？
    1.无锁，偏向锁，轻量级锁和重量级锁。
    2.重量级锁是基于操作系统互斥量实现的，会导致进程在用户态和内核态之间来回切换，开销较大，synchronized内部基于监视器实现，监视器基于底层操作系统实现，因此属于重量级锁，运行效率不高。JDK1.6后为了减少获取锁和释放锁带来的性能消耗提高性能，引入了轻量级锁和偏向锁。
    3.轻量级锁是相对于重量级锁而言的，核心设计实在没有多线程竞争的前提下，减少重量级锁的使用来提高性能。适用于线程交替执行同步代码块的情况，如果同一时刻有多线程访问同一个锁，会导致轻量级锁膨胀成重量级锁。
    4.偏向锁用于在某个线程获取某个锁后，消除这个线程锁重入的开销，看起来似乎是这个线程得到了锁的偏袒。偏向锁的主要目的是在同一个线程多次获取某个所的情况下尽量减少轻量级锁的执行路径，因为轻量级锁需要多次CAS操作，而偏向锁只需要切换ThreadID时执行一次CAS操作，提高效率。出现多线程竞争锁时，JVM会自动撤销偏向锁。偏向锁是进一步提高轻量级锁性能的。
    5.随着锁竞争越来越严重，锁可能从偏向锁升级到轻量级锁再到重量级锁，但在Java中只会单向升级不会降级。

### 15 如何进行锁优化？
    1.减少锁持有的时间：只在有线程安全要求的程序上加锁来尽量减少同步代码块对锁的持有时间。
    2.减小锁粒度：将单个耗时较多的锁操作拆分为多个耗时较少的锁操作来增加锁的并行度，减少同一个锁上的竞争。在减少锁的竞争后，偏向锁、轻量级锁的使用率才会提高，例如ConcurrentHashMap中的分段锁。
    3.读分离：指根据不同的应用场景将锁的功能进行分离以应对不同的变化，最常见的锁分离思想就是读写锁，这样既保证了线程安全又提高了性能。
    4.锁粗化：指为了保障性能，会要求尽可能将锁的操作细化以减少线程持有锁的时间，但如果锁分的太细反而会影响性能提升，这种情况下建议将关联性强的锁操作集中处理。
    5.锁消除：注意代码规范，消除不必要的锁来提高性能。

### 16 线程池是什么？为什么需要线程池？
    1.在生产中为每一个任务创建一个线程存在一些缺陷，如果无限制地大量创建线程会消耗很多资源，影响系统稳定性和性能，产生内存溢出等问题。
    2.线程池是管理一组同构工作线程的资源池，线程池与工作队列密切相关，工作队列中保存了所有需要等待执行的任务。工作线程的任务很简单，从工作队列获取任务，执行任务，返回线程池并等待下一次任务。
    3.线程池通过重用现有的线程，可以在处理多个请求时分摊线程在创建和撤销过程中的开销，另一个好处是当请求到达时工作线程通常已经存在，不会出现等待线程而延迟的任务的执行，提高了响应性。通过调整线程池的大小，可以创建足够多的线程保持处理器处于忙碌状态，同时还可以防止线程过多导致内存资源耗尽。


### 17.创建线程池时，ThreadPoolExecutor构造器中都有哪些参数，有什么含义？
    1.corePoolSize： 线程池核心大小，即在没有任务执行时线程池的大小，并且只有在工作队列满了的情况下才会创建超出这个数量的线程。
    2.maximumPoolSize： 线程池最大大小，表示可同时活动的线程数量的上限。③keepAliveTime：存活时间，如果某个线程的空闲时间超过了存活时间，那么将被标记为可回收的，并且当线程池的当前大小超过基本大小时，这个线程将被终止。④unit： 存活时间的单位，可选的参数为TimeUnit枚举中的几个静态变量： NANOSECONDS、MICROSECONDS、MILLISECONDS、SECONDS。⑤workQueue： 线程池所使用的阻塞队列。⑥thread factory：线程池使用的创建线程工厂方法，可省略，将使用默认工厂。⑦handler：所用的拒绝执行处理策略，可省略，将使用默认拒绝执行策略。

### 18.线程池的阻塞队列有哪些选择？
    1.ArrayBlockingQueue：基于数组的有界阻塞队列。
    2.LinkedBlockingQueue：基于链表的有界阻塞队列。
    3.PriorityBlockingQueue：支持优先级排序的无界阻塞队列。
    4.DelayedWorkQueue：基于优先级队列的无界阻塞队列。
    5.SynchronousQueue：队列内部仅允许容纳一个元素，用于控制互斥的阻塞队列。

### 19.线程池的拒绝执行策略有哪些选择?
    1.AbortPolicy()： 线程池默认的拒绝策略，抛出RejectedExecutionException异常。
    2.CallerRunsPolicy(): 重试添加当前的任务，他会自动重复调用execute()方法。       3.DiscardOldestPolicy(): 抛弃旧的任务，加入新的任务。
    3.DiscardPolicy(): 直接抛弃当前的任务。

### 20.创建线程池的方法有哪些？
    1.可以通过Executors的静态工厂方法创建线程池，内部通过重载ThreadExecutorPool不同的构造器创建线程池。①newFixedThreadPool，创建一个固定长度的线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量，这时线程池的规模将不再变化(如果某个线程由于发生了未预期的异常而结束，那么线程池会补充一个新的线程)。将线程池的核心大小和最大大小都设置为参数中指定的值，创建的线程不会超时，使用LinkedBlockingQueue。      
    2.newCachedThreadPool，创建一个可缓存的线程池，如果线程池的当前规模超过了处理器需求，那么将回收空闲的线程，而当需求增加时，可以添加新的线程，线程池的规模不存在任何限制。将线程池的最大大小设置为Integer.MAX_VALUE，而将核心大小设置为0，并将超时设为1分钟，使用SynchronousQueue，这种方法创建出的线程池可被无限扩展，并当需求降低时自动收缩。
    3.newSingleThreadExecutor，一个单线程的Executor，创建单个工作者线程来执行任务，如果这个线程异常结束，会创建另一个线程来代替。确保依照任务在队列中的顺序来串行执行。将核心线程和最大线程数都设置为1，使用LinkedBlockingQueue。
    4.newScheduledThreadPool，创建一个固定长度的线程池，而且以延迟或定时的方式来执行任务，类似于Timer，使用DelayedWorkQueue。

###  21 线程池的工作原理？
    1.线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。即使队列里面有任务，线程池也不会马上执行它们。\
    2.通过 execute(Runnable command)方法被添加到线程池，任务就是一个 Runnable类型的对象，任务的执行方法就是Runnable类型对象的run()方法。\
    3.如果workerCount<corePoolSize，那么创建并启动一个线程执行新提交的任务。如果workerCount>=corePoolSize，且线程池内的阻塞队列未满，那么将这个任务放入队列。如果workerCount>=corePoolSize，且阻塞队列已满，若满足workerCount<maximumPoolSize,那么还是要创建并启动一个线程执行新提交的任务。若阻塞队列已满，并且workerCount>=maximumPoolSize，则根据 handler所指定的策略来处理此任务，默认的处理方式直接抛出异常。也就是处理任务的优先级为： 核心线程corePoolSize、任务队列workQueue、最大线程maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。
    4.当一个线程完成任务时，它会从队列中取下一个任务来执行。
    5.当一个线程没有任务可执行，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize时，那么这个线程会被停用掉，所以线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。

###  22.简述ExecutorService的生命周期?
    1.ExecutorService的生命周期有3种状态：运行、关闭和已终止。
    2.ExecutorService在初始创建时处于运行状态。
    3.shutdown方法将执行平缓的关闭过程：不再接受新的任务，同时等待已经提交的任务执行完成——包括那些还未开始执行的任务。shutdownNow方法将执行粗暴的关闭过程：它将尝试取消所有运行中的任务，并且不再启动队列中尚未开始执行的任务。在ExecutorService关闭后提交的任务将有“拒绝执行处理器REH”来处理，它会抛弃任务，或者使得execute方法抛出一个未检查的RejectedExecutionException。
    4.等所有任务都完成后，ExecutorService将转入终止状态。可以调用awaitTermination来等待ExecutorService到达终止状态，或者通过调用isTerminated来轮询ExecutorService是否已终止。通常在调用awaitTermination后会理解调用shutdown，从而产生同步地关闭ExecutorService的效果。

### 23.什么是CAS？
    1.CAS指Compare And Swap，比较并交换。CAS(V,E,N)算法包括三个参数，V表示要更新的变量的值，E表示预期的值，N表示新值。在且仅在V的值和E相等时才会将V的值设置为N，如果不同则说明已经有其他线程做了更改，当前线程就什么也不做。最后CAS返回当前V的真实值。
    2.CAS操作采用了乐观锁的思想，有多个线程同时使用CAS操作一个共享变量时只有一个线程会成功，失败的线程不会被挂起仅会被告知失败，并且允许再次尝试，或者放弃操作。基于这样的原理虽然CAS没有使用锁，也可以及时发现其他线程的操作进行适当地并发处理。

### 24.CAS有什么问题？（什么是ABA问题？）如何解决？
    1.CAS算法地实现有一个重要前提：需要取出内存中某时刻的数据，然后在下一刻进行比较、替换，但在这个时间差内数据可能已经发生了变化，导致ABA问题。
    2.ABA问题指线程1从内存V位置取出A，这时线程2也从内存中取出A，并将其首先修改为B，接着又修改为A，这时线程1在进行CAS操作时会发现内存中数据仍是A，然后线程1操作成功。尽管从操作角度来说线程1成功了，但是在该过程中实际上数据已发生了变化但并未被感知到，某些应用场景下可能会出现数据不一致的问题。
    3.乐观锁通过版本号来解决ABA问题，具体的操作是每次执行数据修改操作时都会带上一个版本号，如果预期版本号和数据版本号一致就进行操作，并将版本号加1，否则执行失败。

### 25. 讲一讲wait、sleep、yield、join方法的区别?
    1.wait是Object类的方法，调用wait方法的线程会进入WAITING状态，只有等待其他线程的通知或被中断后才会解除阻塞，调用wait方法会释放锁资源。
    2.sleep是Thread类的方法，调用sleep方法会导致当前线程进入休眠状态，与wait不同的是该方法不会释放锁资源，进入的是TIMED-WAITING状态。
    3.yiled方法会使当前线程让出CPU时间片给优先级相同或更高的线程，回到RUNNABLE状态，与其他线程一起重新竞争CPU时间片。
    4.join方法用于等待其他线程运行终止，如果当前线程调用了另一个线程的join方法，则当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就绪态，等待获取CPU时间片。底层使用的是wait，也会释放锁。

### 26.讲一讲线程中断?
    1.interrupt方法用于向线程发送一个终止信号，会影响该线程内部的中断标识位，这个线程本身不会因为调用了interrupt方法而改变状态，状态的具体变化需要等待接收到中断标识的程序的处理结果判定。
    2.调用interrupt方法不会中断一个正在运行的线程，只会改变内部的中断标识位的值为true。
    3.当调用sleep方法使线程处于TIMED-WAITING状态使，调用interrupt方法会抛出InterruptedException，使线程提前结束TIMED-WAITING状态。在抛出该异常前将清除中断标识位，所以在抛出异常后调用isInterrupted方法返回的值是false。
    4.中断状态是线程固有的一个标识位，可以通过此标识位安全终止线程。比如想终止某个线程时，先调用interrupt方法然后在run方法中根据该线程isInterrupted方法的返回值安全终止线程。

### 27.什么是守护线程？
    1.守护线程是运行在后台的一种特殊线程，独立于控制终端并且周期性地执行某种任务或等待处理某些已发生的事件。守护线程不依赖于终端，但是依赖于JVM，当JVM中仅剩下守护线程时，JVM就会退出。
    2.通过setDaemon方法定义一个守护线程，守护线程的优先级较低，将一个用户线程设置为守护线程必须要在启动守护线程之前。

### 28.start和run方法的区别？
    1.start方法用于启动线程，真正实现了多线程，调用了start方法后，会在后台创建一个新的线程来执行，不需要等待run方法执行完毕就可以继续执行其他代码。调用start方法时，该线程处于就绪状态，并没有开始运行。
    2.run方法也叫做线程体，包含了要执行的线程的逻辑代码，在调用run方法并没有创建新的线程，而是直接运行run方法中的代码。

### 29.synchronized锁的原理是什么?和lock锁有什么区别?
	1.synchronized是借用对象markword中的标记以及monitor监控器生成monitorEnter以及monitorExit指令以及对应的计数器.

# mybatis相关面试题

### 1.#{} 和 ${} 的区别是什么？
    ${}是Properties文件中的变量占位符，他可以用在标签属性值和sql内部，属于静态文件替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。即字符串拼接
    #{}是sql的参数占位符，mybatis会将sql中的#{}替换为?,在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的？设置参数 即为预编译处理

### 2.xml映射文件除了常见的update｜inster｜delete｜select｜标签之外还有什么标签？
    还有如：<resultMap>,<parameterMap>,<sql>,<include>,<selectKey>

### 3.在项目中，一般情况下xml映射文件，都会写一个dao接口与之对应，请问这个dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？
    dao接口是我们常说的mapper接口，接口的权限名称，就是映射文件的namespace的值，接口的方法名称就是MappedStatement的id值，
    接口方法内的参数，是传递给sql的参数
    
    mapper接口没有实现类，当调用接口方式时候，接口权限名称，+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，
    com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById
    的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。
    
    dao接口里的方式是不能被重载的，因为是权限名称加方法名称的保存寻找策略
    
    dao接口的工作原理是jdk的动态代理模式，mybatis运行时会使用jdk的动态代理为dao接口生成代理的proxy代理对象，代理对象会拦截接口方法，
    转而执行MappedStatement所代表的sql，然后将sql执行的结果返回

### 4.mybatis是如何进行分页的？分页插件的原理是什么？
    mybatis使用RowBounds进行分页的，它是针对resultSet结果集针对的内存分页，而非物理分页，以在sql内直接书写带有物理分页的参数来完成物理分页功能，
    也可以使用分页插件来完成物理分页。
    
    分页插件使用的基本原理是Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，
    添加对应的物理分页语句和物理分页参数。
    
    如：select * from student，拦截sql后重写为：select t.* from （select * from student）t limit 0，10
    

# 三:JVM 

### 1：类的加载机制是什么?
    类加载到内存中主要有5个阶段，分别为
    1.加载：将Class文件读取到运行时数据区的方法区内，在堆中创建Class对象，并封装类在方法区的数据结构的过程。
    2.验证：主要用于确保Class文件符合当前虚拟机的要求，保障虚拟机自身的安全，只有通过验证的Class文件才能被JVM加载。
    3.准备：主要工作是在方法区中为类变量分配内存空间并设置类中变量的初始值。
    4.解析：将常量池中的符号引用替换为直接引用。
    5.初始化：主要通过执行类构造器的<client>方法为类进行初始化，该方法是在编译阶段由编译器自动收集类中静态语句块和变量的赋值操作组成的。JVM规定，只有在父类的<client>方法都执行成功后，子类的方法才可以被执行。在一个类中既没有静态变量赋值操作也没有静态语句块时，编译器不会为该类生成<client>方法。


# 四：spring相关面试？
  
### 1：什么是控制反转？什么是依赖注入？
    控制反转：IOC-Inversion of Control；控制反转是一种设计思想，不是一种技术，
            Ioc意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制
            
### 2：spring有哪几种注入方式？
    1.构造注入
    2.set注入
    3.注解
    
### 2：BeanFactory和ApplicationContext有什么区别？
    BeanFactory和ApplicationContext是Spring的两大核心接口，
    都可以当做Spring的容器。其中ApplicationContext是BeanFactory的子接口。
    
    BeanFactory是spring最底层的一个接口，包含了各种bean的定义，包括：读取bean的配置文件，
    管理bean 的加载，实例化，控制bean的生命周期，维护bean的依赖关系
    
    ApplicationContext：他是在启动的时，一次性创建了所有的bean，这样在容器启动的时候，我们可以发现，spring
    中存在配置错误，这样利于检查所有所有依赖是否注入，ApplicationContext启动后，预载入所有单利的bean，通过预载入单实例bean ，
    确保当你需要的时候，你就不用等待，因为它们已经创建好了。
    
    
    相对于基本的BeanFactory，ApplicationContext唯一不足的地方是，占用内存空间。当应用程序配置Bean较多时，程序启动较慢。
    


### 3：将Spring配置到你项目中有哪几种方式方式？
    




# 四:Redis 相关面试

### 1：redis如何保证防止缓存穿透和雪崩?
    1.缓存穿透是:查询一个一定不存在的数据,由于缓存是不命中的情况下去查询数据库,查不到数据则不学入缓存,这将导致这个不存在的数据每次都要去数据库查询,造成缓存穿透
    解决办法:**布隆过滤**
    对所有查询的数据以hash的形式存储,在控制层进行校验,不符合的则进行丢弃,还有最常见的则是才用布隆过滤器,将所有的数据哈希到一个足够大的bigmap中,一个一定不会出现的数据会被这个bigmap拦截,从而避免底层查询系统造成的压力
    1.2 什么事布隆过滤器?
    基本原理是:位数组+K个独立hash函数,将hash函数对应的值得位数组置1,查找的时候发现所有的hash函数对应的都是1说明存在,很明显这个过程并不能保证查找的结果100%正确,同事也不支持删除一个已经插入的关键字,因为关键字对应的位会会牵动其他的关键字,所以一个简单的改造就是 counting Bloom filter ,用一个counter 数组代替位数组,就可以支持删除了。添加时增加计数器，删除时减少计数器。
    2.缓存雪崩?
    如果缓存集中在一段时间内失效,发生大量的缓存穿透,所有的查询都落在数据库上,造成缓存雪崩
    解决办法:没有完美解决办法,但可以分析用户的行为,尽量让失效时间点均匀分布,很多人都设计考虑用加锁或者队列的方式保证缓存的单线程（进程）写,从而避免失效时大量的并发请求落到底层存储系统上。
    还可以做双缓存策率

### 2. Redis 如何保证模糊查询?
    1.有三个通配符
    	*   ?  [] 
    	*: 通配任意多个字符
    	?: 通配单个字符
    	[]: 通配括号内的某1个字符


### Redis的哨兵和cluster架构的区别?
    哨兵是:集群监控,负责监控redis master和slave 进程是否正常工作
         消息通知:如果某个redis的实例有故障,那么哨兵负责发送消息作为报警通知给管理员
          故障转移:如果master的node挂掉了,会自动转移到slave node 上
          配置中心:如果故障转移发生了,通知client客户端新的master的地址
    cluster类型:就是redis 集群,是一个提供在多个redis间共享数据的程序集
                redis集群通过分区来提供一定程度上的可用性,在实际环境中当某个环境宕机或者不可达的情况下,继续处理命令,优势在于,自动分割数据到不同的节点上,整理集群的部分节点失败或者不可达的情况下,能够继续处理命令.



# 五 dubbo相关面试题

### 1.什么是dubbo
    是一款高性能，轻量级的开源java RPC框架，提供了三大核心功能，面向接口的远程方法调用，智能容错和负载均衡，服务自动注册，发现，
    简单的来说，dubbo是一款分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。

    
### 1.dubbo如何优雅停机的？
    dubbo是通过JDK的shutdownHook来完成优雅停机的，所以如果使用kill -9 PID 等强制关闭指令来关闭服务，是不会执行优雅停机的，
    只能通过kill pid 时候才能优雅停机
    
### 2.你觉得dubbo好还是springcloud好？
    只有适合不适合的问题，框架没有好坏
    
  
# 五 springcloud相关面试题

### 1.eureka和zookeeper的区别？
    CAP 理论：一致性：Consistency
             可用性：Availability
             分区错容性：Partition tolerance	
    
    eureka基于Ap：可用性和和分区错容性
    zookeeper基于：CP：一致性和分区错容性
    
### 2.什么是Ribbon？
    Ribbon是客户端提供负载均衡的功能的服务，
    它内部提供了一个叫做ILoadBalance的接口代表负载均衡器的操作，负载均衡器
        
### 3.到底什么是RestTemplate？
    REST是一种互联网的系统架构风格，RestTemplate字面意思就是支持Rest风格的互联网请求方式模版，他是一种支持
    REST风格并简化了发起http请求访问资源的以及处理响应的方式，REST 指的是一组架构约束条件和原则。满足这些约束条件和原则的应用程序或设计就是 RESTful。
    而Restful接口就是给一个外部系统提供访问当前系统的一个方法。
 
### 4.
    
       
      
    

